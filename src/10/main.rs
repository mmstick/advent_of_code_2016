#![feature(alloc_system)]
extern crate alloc_system;
extern crate arrayvec;
extern crate time;

use arrayvec::ArrayVec;
use std::cmp::{min, max};
use std::collections::HashMap;
use std::collections::VecDeque;

const INPUT: &'static str = include_str!("input.txt");

/// An `Instruction` given to the bots
#[derive(Debug, PartialEq)]
enum Instruction {
    Take(u8, u8),                   // Value A goes to bot B
    Give(u8, Recipient, Recipient)  // Bot A gives low to Recipient B and high to Recipient C
}

/// The `Recipient` of a value can either be a `Bin` or a `Bot`.
#[derive(Copy, Clone, Debug, PartialEq)]
enum Recipient { Bin(u8), Bot(u8) }

/// Bots can only hold two values at a time: a left and right value.
#[derive(Debug)]
struct Bot { left: u8, right: u8 }

impl Bot {
    /// Determines if a bot is comparing the match that we are looking for.
    fn contains_match(&self, cmp_left: u8, cmp_right: u8) -> bool {
        self.right != self.left && (self.left == cmp_left || self.left == cmp_right) &&
            (self.right == cmp_left || self.right == cmp_right) 
    }
}

/// Take an unparsed `instruction` as a string slice and return the parsed `Instruction` values
fn parse_instruction(instruction: &str) -> Instruction {
    let commands = instruction.split_whitespace().collect::<ArrayVec<[&str; 12]>>();
    match commands[0] {
        "bot" => {
            let id = commands[1].parse::<u8>().unwrap();
            let low_recipient = match commands[5] {
                "bot" => Recipient::Bot(commands[6].parse::<u8>().unwrap()),
                _     => Recipient::Bin(commands[6].parse::<u8>().unwrap()),
            };
            let high_recipient = match commands[10] {
                "bot" => Recipient::Bot(commands[11].parse::<u8>().unwrap()),
                _     => Recipient::Bin(commands[11].parse::<u8>().unwrap()),
            };
            Instruction::Give(id, low_recipient, high_recipient)
        },
        _ => {
            let value = commands[1].parse::<u8>().unwrap();
            let bot   = commands[5].parse::<u8>().unwrap();
            Instruction::Take(value, bot)
        }
    }
}

/// A list of instructions to process that is generated by parsing a string list of instructions.
struct Instructions { data: VecDeque<Instruction> }

impl<'a> From<&'a str> for Instructions {
    fn from(input: &'a str) -> Instructions {
        Instructions {
            data: input.lines().map(parse_instruction).collect::<VecDeque<Instruction>>()
        }
    }
}

/// Updates a bot's values in the given `$bots` `HashMap`.
macro_rules! update_bot {
    ($bots:ident, $bot_id:ident, $value:ident) => {{
        if $bots.contains_key(&$bot_id) {
            let mut bot = $bots.get_mut(&$bot_id).unwrap();
            if bot.left == 0 { bot.left = $value; } else { bot.right = $value; }
        } else {
            let _ = $bots.insert($bot_id, Bot { left: $value, right: 0 });
        }
    }}
}

/// Computes which bot is responsible for comparing two set values and the product of
/// bins 0, 1, and 2.
fn calculate<I>(bots: &mut HashMap<u8, Bot>, bin: &mut HashMap<u8, u8>, cmp_left: u8,
    cmp_right: u8, instructions: I) -> (u8, u16) where I: Into<Instructions>
{
    let mut instructions: Instructions = instructions.into();
    let mut bot_compared = 0;
    let mut bins_set     = 0;
    
    loop {
        // Pop an instruction from the front
        let instruction = if let Some(instruction) = instructions.data.pop_front() { instruction } else { break };
        let mut completed = false;

        match instruction {
            Instruction::Take(value, bot) => {
                completed = true;

                // If the key does not exist, add the key with the `left` value set to `value` and the
                // `right` value as `0`. Otherwise, if the `left` value is `0` then set the `left` value to
                // the `value`, else set the `right` value to `value`. Got that? Good.
                if bots.contains_key(&bot) {
                    let mut bot = bots.get_mut(&bot).unwrap();
                    if bot.left == 0 { bot.left = value; } else { bot.right = value; }
                } else {
                    let _ = bots.insert(bot, Bot { left: value, right: 0 });
                }
            },
            Instruction::Give(bot_id, low, high) => {
                // These two `Option` values will contain the values that need to be changed after checking.
                // This is done for safety to prevent the `bots` hashmap from being mutably borrowed twice.
                let mut update_low_bot:  Option<(u8, u8)> = None;
                let mut update_high_bot: Option<(u8, u8)> = None;

                // Mutably borrow the bot that needs to transfer it's values. Note that we cannot mutably
                // borrow more than once, so if another bot needs to be modified we will store that bot's ID
                // and associated value in the `Option` variables above.
                if let Some(mut bot) = bots.get_mut(&bot_id) {
                    // Only if the bot is holding two values will the bot take action.
                    if bot.left != 0 && bot.right != 0 {
                        // If the bot's two values are what we are searching for, set the bot ID for return.
                        if bot.contains_match(cmp_left, cmp_right) { bot_compared = bot_id; }

                        completed     = true;
                        let low_value  = min(bot.left, bot.right);
                        let high_value = max(bot.left, bot.right);

                        // Utilized to macth the low and high recipient's values to their respective places.
                        // If a bot is to be set then that bot's ID and new value will be marked for later use.
                        // If a bin is set that matches the bins we want, the `bins_set` value is increased.
                        macro_rules! match_recipient {
                            ($recipient:ident, $update:ident, $value:expr) => {{
                                match $recipient {
                                    Recipient::Bin(bin_id) => {
                                        let _ = bin.insert(bin_id, $value);
                                        if bin_id == 0 || bin_id == 1 || bin_id == 2 { bins_set += 1; }
                                    },
                                    Recipient::Bot(bot_id) => $update = Some((bot_id, $value))
                                }
                            }}
                        }

                        match_recipient!(low, update_low_bot, low_value);
                        match_recipient!(high, update_high_bot, high_value);

                        // The bot is now no longer holding a value.
                        bot.left  = 0;
                        bot.right = 0;
                    }
                }

                // Update the value of the low bot if it needs to be updated.
                if let Some((bot_id, value)) = update_low_bot { update_bot!(bots, bot_id, value); }

                // Update the value of the high bot if it needs to be updated.
                if let Some((bot_id, value)) = update_high_bot { update_bot!(bots, bot_id, value); }
            },
        }

        // If the instruction was not used, push it to the back
        if !completed { instructions.data.push_back(instruction); }
        
        if bins_set == 3 { break }
    }
    (bot_compared, bin[&0] as u16 * bin[&1] as u16 * bin[&2] as u16)
}

fn main() {
    let begin = time::precise_time_ns();
    let mut bots: HashMap<u8, Bot> = HashMap::new();
    let mut bins: HashMap<u8,  u8> = HashMap::new();
    let (bot, product) = calculate(&mut bots, &mut bins, 61, 17, INPUT);
    let end = time::precise_time_ns();
    println!("The bot that compares value-61 and value-17 chips is #{}.", bot);
    println!("The product of bins 0, 1, and 2 is {}.", product);
    println!("Day 10 Execution Time: {} milliseconds", ((end - begin) as f64 / 1_000_000f64));
}

#[test]
fn bot_compare_test() {
    let input = r#"value 5 goes to bot 2
        bot 2 gives low to bot 1 and high to bot 0
        value 3 goes to bot 1
        bot 1 gives low to output 1 and high to bot 0
        bot 0 gives low to output 2 and high to output 0
        value 2 goes to bot 2"#;

    let bots = &mut HashMap::new();
    let bins = &mut HashMap::new();
    let (bot, product) = calculate(bots, bins, 5, 2, input);
    assert_eq!(2, bot);
    assert_eq!(30, product);
}

#[test]
fn parser_test() {
    let input = r#"value 5 goes to bot 2
        bot 2 gives low to bot 1 and high to bot 0
        value 3 goes to bot 1
        bot 1 gives low to output 1 and high to bot 0
        bot 0 gives low to output 2 and high to output 0
        value 2 goes to bot 2"#;

    let expected = [
        Instruction::Take(false, 5, 2),
        Instruction::Give(false, 2, Recipient::Bot(1), Recipient::Bot(0)),
        Instruction::Take(false, 3, 1),
        Instruction::Give(false, 1, Recipient::Bin(1), Recipient::Bot(0)),
        Instruction::Give(false, 0, Recipient::Bin(2), Recipient::Bin(0)),
        Instruction::Take(false, 2, 2),
    ];

    for (actual, expected) in Instructions::from(input).data.iter().zip(expected.iter()) {
        assert_eq!(*actual, *expected);
    }

    assert_eq!(6, Instructions::from(input).data.iter().count());
}